import streamlit as st
import speech_recognition as sr
import queue
import threading
from datetime import datetime
import os

st.set_page_config(page_title="ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—", page_icon="ğŸ’¬", layout="wide")


class RealTimeTranscription:
    def __init__(self):
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        self.is_listening = False
        self.transcription_placeholder = None
        os.makedirs("recordings", exist_ok=True)

    def start_listening(self):
        self.is_listening = True
        threading.Thread(target=self._listen_continuously, daemon=True).start()

    def stop_listening(self):
        self.is_listening = False

    def _listen_continuously(self):
        with self.microphone as source:
            # ãƒã‚¤ã‚ºèª¿æ•´
            self.recognizer.adjust_for_ambient_noise(source, duration=1)

            while self.is_listening:
                try:
                    # éŸ³å£°ã‚’ listen
                    audio = self.recognizer.listen(
                        source, timeout=None, phrase_time_limit=5
                    )

                    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§éŸ³å£°èªè­˜ã‚’å®Ÿè¡Œ
                    threading.Thread(
                        target=self._transcribe_audio, args=(audio,), daemon=True
                    ).start()

                except Exception as e:
                    st.error(f"ãƒªã‚¹ãƒ‹ãƒ³ã‚°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ: {e}")

    def _transcribe_audio(self, audio):
        try:
            # éŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›
            text = self.recognizer.recognize_google(audio, language="ja-JP")

            # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            audio_path = f"recordings/recording_{timestamp}.wav"
            with open(audio_path, "wb") as f:
                f.write(audio.get_wav_data())

            # ç”»é¢ã«æ–‡å­—èµ·ã“ã—çµæœã‚’è¡¨ç¤º
            if self.transcription_placeholder:
                current_text = self.transcription_placeholder.session_state.get(
                    "transcription", ""
                )
                updated_text = current_text + text + "\n"
                self.transcription_placeholder.text_area(
                    "æ–‡å­—èµ·ã“ã—", value=updated_text, height=300
                )
                self.transcription_placeholder.session_state.transcription = (
                    updated_text
                )

        except sr.UnknownValueError:
            st.warning("éŸ³å£°ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ")
        except Exception as e:
            st.error(f"æ–‡å­—èµ·ã“ã—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ: {e}")


def main():
    st.title("ğŸ™ï¸ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—ã‚¢ãƒ—ãƒª")

    # ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åˆæœŸåŒ–
    if "transcriber" not in st.session_state:
        st.session_state.transcriber = RealTimeTranscription()

    # æ–‡å­—èµ·ã“ã—è¡¨ç¤ºç”¨ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
    transcription_placeholder = st.empty()
    st.session_state.transcriber.transcription_placeholder = transcription_placeholder

    # ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³
    col1, col2 = st.columns(2)
    with col1:
        if st.button("ğŸ”´ éŒ²éŸ³é–‹å§‹"):
            st.session_state.transcriber.start_listening()
            st.success("éŒ²éŸ³ã‚’é–‹å§‹ã—ã¾ã—ãŸ")

    with col2:
        if st.button("â¹ï¸ éŒ²éŸ³åœæ­¢"):
            st.session_state.transcriber.stop_listening()
            st.info("éŒ²éŸ³ã‚’åœæ­¢ã—ã¾ã—ãŸ")

    # åˆæœŸãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    if "transcription" not in st.session_state:
        st.session_state.transcription = ""


if __name__ == "__main__":
    main()

#1/24_æ–‡å­—èµ·ã“ã—ç²¾åº¦ã‚ãŒã‚‹app.pyãŒç”»é¢ã«å³æ™‚åæ˜ ã•ã‚Œãªã„
